---
title: "qc_data_graphs"
format: html
---

## Library and Data

```{r}
#| label: library_function 

library(tidyverse)
library(knitr)
library(readxl)
library(data.table)
library(vegan)
library(scales)
```

```{r}
#| label: read-csvs

qc_data <- read.csv("/Users/ellaandonov/World_Corals/Cleaned data CSVs/qc_data.csv")
```

## Taxonomic Counts

```{r}
#| label: taxonomic-counts

# Count unique categories for each taxonomic level
taxonomic_counts <- qc_data %>%
  summarise(across(
    c(host_phylum, host_class, host_order, host_genus, host_species), 
    ~n_distinct(.x, na.rm = TRUE)
  )) %>%
  # Optional: Pivot to long format for a cleaner table view
  tidyr::pivot_longer(
    cols = everything(), 
    names_to = "Taxonomic_Level", 
    values_to = "Unique_Count"
  )

# View the counts
print(taxonomic_counts)
```

## Dendrograms

```{r}
avg_metabolite_values_family <- qc_data |>
  group_by(host_family) |> 
  filter(!is.na(host_family)) |> 
  summarise(across(starts_with("x"), mean, na.rm = TRUE)) |>
  ungroup()
```

```{r}
# turn host_family into rownames and create numeric matrix for vegdist
mat_family <- avg_metabolite_values_family %>%
  as.data.frame()                     # ensure data.frame for rownames()
rownames(mat_family) <- mat_family$host_family
mat_family <- mat_family[ , setdiff(names(mat_family), "host_family")]  # drop the column now that it's rownames

mat_family[] <- lapply(mat_family, as.numeric)

mat_family <- mat_family %>%
  mutate_all(~ifelse(is.na(.), 0, .))   # replace NAs with 0s (common for abundance data)
```

```{r}
bray_curtis_family <- vegdist (sqrt (mat_family), method = 'bray') 
# percentage cover data are transformed by square root
cluster.single <- hclust (d = bray_curtis_family, method = 'single')
cluster.complete <- hclust (bray_curtis_family, 'complete')
cluster.average <- hclust (bray_curtis_family, 'average')
```

```{r}
# Set background color for the plot area and device
par(bg = "#000042")               # device background
par(col = "white",                # axis & text color
    col.axis = "white",
    col.lab  = "white",
    col.main = "white",
    col.sub  = "white",
    fg = "white")                 # foreground (box, axes)

# Plot dendrogram with white lines and labels
plot(cluster.average,
     main = "Dendrogram by Family",
     xlab = "Families",
     sub = "",
     cex = 0.6,
     col = "white",               # dendrogram lines
     col.lab = "white",
     col.main = "white",
     col.axis = "white",
     labels = cluster.average$labels,
     col.lab = "white")

# Draw cluster rectangles in white
rect.hclust(cluster.average, k = 10, border = "white", lwd = 2)

```

```{r}
#| label: dendrogram-host-origin 

# Get the metabolites that are not Host
not_host_metabolite = metabolite_clean |>
  filter(!(refined_origin %in% c("Host", "Unknown"))) |>
  pull(metabolite)

avg_metabolite_values_family_host = avg_metabolite_values_family |>
  select(-any_of(not_host_metabolite))

# turn host_family into rownames and create numeric matrix for vegdist
mat_family <- avg_metabolite_values_family_host %>%
  as.data.frame()                     # ensure data.frame for rownames()
rownames(mat_family) <- mat_family$host_family
mat_family <- mat_family[ , setdiff(names(mat_family), "host_family")]  # drop the column now that it's rownames

mat_family[] <- lapply(mat_family, as.numeric)

mat_family <- mat_family %>%
  mutate_all(~ifelse(is.na(.), 0, .))   # replace NAs with 0s (common for abundance data)
```

```{r}
bray_curtis_family <- vegdist (sqrt (mat_family), method = 'bray') 
# percentage cover data are transformed by square root
cluster.single <- hclust (d = bray_curtis_family, method = 'single')
cluster.complete <- hclust (bray_curtis_family, 'complete')
cluster.average <- hclust (bray_curtis_family, 'average')
```

```{r}
# Set background color for the plot area and device
par(bg = "#000042")               # device background
par(col = "white",                # axis & text color
    col.axis = "white",
    col.lab  = "white",
    col.main = "white",
    col.sub  = "white",
    fg = "white")                 # foreground (box, axes)

# Plot dendrogram with white lines and labels
plot(cluster.average,
     main = "Dendrogram by Family, Host Origin Only",
     xlab = "Families",
     sub = "",
     cex = 0.6,
     col = "white",               # dendrogram lines
     col.lab = "white",
     col.main = "white",
     col.axis = "white",
     labels = cluster.average$labels,
     col.lab = "white")

# Draw cluster rectangles in white
rect.hclust(cluster.average, k = 10, border = "white", lwd = 2)

```

```{r}
#| label: install_package

install.packages("ggdendro")
```

```{r}
#| label: load_packages

library(ggdendro)
library(RColorBrewer)
```

```{r}
#| label: dendrogram_colored_by_Scleractinia

library(tidyverse)
library(vegan)
library(dendextend)
library(RColorBrewer)

# --- build matrix (your code, slightly adapted) ---
avg_metabolite_values_family <- qc_data |>
  group_by(host_family) |> 
  filter(!is.na(host_family)) |> 
  summarise(across(starts_with("x"), mean, na.rm = TRUE)) |>
  ungroup()

mat_family <- avg_metabolite_values_family %>%
  as.data.frame()
rownames(mat_family) <- mat_family$host_family
mat_family <- mat_family[ , setdiff(names(mat_family), "host_family")]
mat_family[] <- lapply(mat_family, as.numeric)
mat_family <- mat_family %>% mutate_all(~ifelse(is.na(.), 0, .))

bray_curtis_family <- vegdist(sqrt(mat_family), method = 'bray')
cluster.average <- hclust(bray_curtis_family, method = 'average')

# --- get host_order by family from original qc_data ---
host_order_by_family <- qc_data %>%
  filter(!is.na(host_family)) %>%
  group_by(host_family) %>%
  summarize(host_order = first(na.omit(host_order))) %>%
  ungroup()

# --- palette: Scleractinia vs Other ---
pal <- brewer.pal(3, "Set1")[1:2]
names(pal) <- c("Scleractinia", "Other")

# map ordered labels -> colors
dend <- as.dendrogram(cluster.average)
family_order <- labels(dend)
label_group <- host_order_by_family$host_order[match(family_order, host_order_by_family$host_family)]
label_group[is.na(label_group)] <- "Other"             # fallback
label_colors <- ifelse(label_group == "Scleractinia", pal["Scleractinia"], pal["Other"])

# apply colors to labels (and optionally to branches near leaves)
dend <- dend %>%
  set("labels_cex", 0.7) %>%
  set("labels_col", label_colors)

# If you want to color the branches that connect groups you can try coloring branches by cutting
# the dendrogram into two clusters using the known groups. This is an approximation:
group_flag <- ifelse(label_group == "Scleractinia", 1, 2)
# Create cluster id vector by mapping label order -> group flag
# (note: this will not recolor deeper internal edges perfectly but is useful visually)
# Convert to colors by label and then color labels already done above

# Plot (base R) with dark background like you used
par(bg = "#000042", col = "white", col.axis = "white", col.lab = "white",
    col.main = "white", col.sub = "white", fg = "white")
plot(dend, main = "Dendrogram by Family",
     xlab = "", sub = "", ylab = "Height")
# labels are colored; branches remain default but the leaves show group membership

```

```{r}
#| label: dendrogram_colored_by_host_order

library(tidyverse)
library(vegan)
library(dendextend)
library(RColorBrewer)

# --- build matrix of average metabolite values by family ---
avg_metabolite_values_family <- qc_data |>
  group_by(host_family) |> 
  filter(!is.na(host_family)) |> 
  summarise(across(starts_with("x"), mean, na.rm = TRUE)) |>
  ungroup()

mat_family <- avg_metabolite_values_family %>%
  as.data.frame()

rownames(mat_family) <- mat_family$host_family
mat_family <- mat_family[, setdiff(names(mat_family), "host_family")]
mat_family[] <- lapply(mat_family, as.numeric)
mat_family <- mat_family %>% mutate_all(~ifelse(is.na(.), 0, .))

# --- distance + clustering ---
bray_curtis_family <- vegdist(sqrt(mat_family), method = "bray")
cluster.average <- hclust(bray_curtis_family, method = "average")

# --- get host_order by family ---
host_order_by_family <- qc_data %>%
  filter(!is.na(host_family)) %>%
  group_by(host_family) %>%
  summarize(host_order = first(na.omit(host_order))) %>%
  ungroup()

# --- prepare dendrogram and label mapping ---
dend <- as.dendrogram(cluster.average)
family_order <- labels(dend)

label_order <- host_order_by_family$host_order[
  match(family_order, host_order_by_family$host_family)
]
label_order[is.na(label_order)] <- "Other"

# --- build bold color palette ---
unique_orders <- unique(label_order)
n_orders <- length(unique_orders)

max_brewer <- 8
if (n_orders <= max_brewer) {
  pal_base <- brewer.pal(max(3, n_orders), "Dark2")[1:n_orders]
} else {
  pal_base <- colorRampPalette(brewer.pal(max_brewer, "Dark2"))(n_orders)
}
names(pal_base) <- unique_orders

# Force Scleractinia to bright red
pal <- pal_base
if ("Scleractinia" %in% names(pal)) {
  pal["Scleractinia"] <- "#E41A1C"
}

# --- apply colors ---
label_colors <- pal[label_order]
cluster_ids <- as.numeric(factor(label_order, levels = unique_orders))

dend <- dend %>%
  set("labels_cex", 0.7) %>%
  set("labels_col", label_colors)

dend_colored <- color_branches(
  dend,
  clusters = cluster_ids,
  col = pal
)

# --- plot with white background and external legend ---
par(
  bg = "white",
  fg = "black",
  col = "black",
  col.axis = "black",
  col.lab = "black",
  col.main = "black",
  mar = c(5, 4, 4, 10),  # space on right for legend
  xpd = NA
)

plot(
  dend_colored,
  main = "Dendrogram by Family",
  xlab = "",
  ylab = "Height",
  sub = ""
)

legend(
  "topright",
  inset = c(-0.45, 0),
  legend = unique_orders,
  fill = pal,
  border = NA,
  bty = "n",
  cex = 0.8,
  title = "Order"
)
```

```{r}
metabolite_clean <- read.csv("/Users/ellaandonov/World_Corals/Cleaned data CSVs/metabolite_clean.csv")
```

```{r}
#| label: dendrogram_colored_by_Scleractinia_host_origin_only

library(dendextend)
library(RColorBrewer)
library(dplyr)
library(vegan)    

# Get the metabolites that are not Host
not_host_metabolite = metabolite_clean |>
  filter(!(refined_origin %in% c("Host", "Unknown"))) |>
  pull(metabolite)

avg_metabolite_values_family_host = avg_metabolite_values_family |>
  select(-any_of(not_host_metabolite))

# turn host_family into rownames and create numeric matrix for vegdist
mat_family <- avg_metabolite_values_family_host %>%
  as.data.frame()                     # ensure data.frame for rownames()
rownames(mat_family) <- mat_family$host_family
mat_family <- mat_family[ , setdiff(names(mat_family), "host_family")]  # drop the column now that it's rownames

mat_family[] <- lapply(mat_family, as.numeric)

mat_family <- mat_family %>%
  mutate_all(~ifelse(is.na(.), 0, .))   # replace NAs with 0s (common for abundance data)

bray_curtis_family <- vegdist (sqrt (mat_family), method = 'bray') 
# percentage cover data are transformed by square root
cluster.single <- hclust (d = bray_curtis_family, method = 'single')
cluster.complete <- hclust (bray_curtis_family, 'complete')
cluster.average <- hclust (bray_curtis_family, 'average')

# host_order per family
host_order_by_family <- qc_data %>%
  filter(!is.na(host_family)) %>%
  group_by(host_family) %>%
  summarize(host_order = first(na.omit(host_order))) %>%
  ungroup()

# convert to dendrogram
dend <- as.dendrogram(cluster.average)

# match label order to host_order
family_order <- labels(dend)
label_group <- host_order_by_family$host_order[
  match(family_order, host_order_by_family$host_family)
]
label_group[is.na(label_group)] <- "Other"

# palette: Scleractinia vs Other
pal <- brewer.pal(3, "Set1")[1:2]
names(pal) <- c("Scleractinia", "Other")

label_colors <- ifelse(
  label_group == "Scleractinia",
  pal["Scleractinia"],
  pal["Other"]
)

# apply ONLY label (tip) colours
dend <- dend %>%
  set("labels_col", label_colors) %>%
  set("labels_cex", 0.7)

# plotting (branches stay white)
par(bg = "#000042",
    col = "white",
    col.axis = "white",
    col.lab  = "white",
    col.main = "white",
    col.sub  = "white",
    fg = "white")

plot(dend,
     main = "Dendrogram by Family â€” Host Origin Only",
     xlab = "",
     ylab = "Height",
     sub = "")
```

```{r}
#| label: dendrogram_colored_by_Scleractinia_host_origin_only

library(dendextend)
library(RColorBrewer)
library(dplyr)
library(vegan)

# --- select metabolites that are Host-origin only (remove non-host / unknown) ---
not_host_metabolite <- metabolite_clean |>
  filter(!(refined_origin %in% c("Host", "Unknown"))) |>
  pull(metabolite)

avg_metabolite_values_family_host <- avg_metabolite_values_family |>
  select(-any_of(not_host_metabolite))

# --- prepare matrix for distance calculation ---
mat_family <- avg_metabolite_values_family_host %>%
  as.data.frame()
rownames(mat_family) <- mat_family$host_family
mat_family <- mat_family[, setdiff(names(mat_family), "host_family")]
mat_family[] <- lapply(mat_family, as.numeric)
mat_family <- mat_family %>% mutate_all(~ifelse(is.na(.), 0, .))

# --- distance + clustering (use 'average' for plotting as before) ---
bray_curtis_family <- vegdist(sqrt(mat_family), method = "bray")
cluster.single   <- hclust(d = bray_curtis_family, method = "single")
cluster.complete <- hclust(d = bray_curtis_family, method = "complete")
cluster.average  <- hclust(d = bray_curtis_family, method = "average")

# --- host_order per family (mapping for coloring) ---
host_order_by_family <- qc_data %>%
  filter(!is.na(host_family)) %>%
  group_by(host_family) %>%
  summarize(host_order = first(na.omit(host_order))) %>%
  ungroup()

# --- convert to dendrogram and get ordered family labels ---
dend <- as.dendrogram(cluster.average)
family_order <- labels(dend)

# --- map labels -> host_order, fallback to "Other" ---
label_order <- host_order_by_family$host_order[
  match(family_order, host_order_by_family$host_family)
]
label_order[is.na(label_order)] <- "Other"

# --- build a bold color palette for each unique host_order ---
unique_orders <- unique(label_order)
n_orders <- length(unique_orders)
max_brewer <- 8

if (n_orders <= max_brewer) {
  pal_base <- brewer.pal(max(3, n_orders), "Dark2")[1:n_orders]
} else {
  pal_base <- colorRampPalette(brewer.pal(max_brewer, "Dark2"))(n_orders)
}
names(pal_base) <- unique_orders

# Force Scleractinia to bright red (if present)
pal <- pal_base
if ("Scleractinia" %in% names(pal)) {
  pal["Scleractinia"] <- "#E41A1C"
}

# --- colors for each leaf based on its host_order ---
label_colors <- pal[label_order]

# numeric cluster ids for branch coloring (one id per leaf in label order)
cluster_ids <- as.numeric(factor(label_order, levels = unique_orders))

# apply label aesthetics (colored tip labels)
dend <- dend %>%
  set("labels_cex", 0.7) %>%
  set("labels_col", label_colors)

# color branches leading to leaves of the same host_order
dend_colored <- color_branches(dend, clusters = cluster_ids, col = pal)

# --- plotting: white background, black text, legend far to the right ---
par(
  bg = "white",
  fg = "black",
  col = "black",
  col.axis = "black",
  col.lab = "black",
  col.main = "black",
  mar = c(5, 4, 4, 12),  # make extra room on right for legend
  xpd = NA               # allow legend to be drawn outside the plot region
)

plot(
  dend_colored,
  main = "Dendrogram by Family â€” Host Origin Only",
  xlab = "",
  ylab = "Height",
  sub = ""
)

# legend placed well outside the plot area so it does not overlap
legend(
  "topright",
  inset = c(-0.60, 0),   # push legend farther to the right
  legend = unique_orders,
  fill = pal,
  border = NA,
  bty = "n",
  cex = 0.85,
  title = "Order"
)
```

## Collectors Curve

```{r}
#| label: collectors-curve-all-metabolites

comm_matrix = qc_data |>
  select(c(sample, grep("^x", names(qc_data), value = TRUE))) |>
  column_to_rownames(var = "sample")

comm_matrix = comm_matrix |>
  mutate(across(where(is.numeric), ~ ifelse(.x > 0, 1, 0)))

curve_collector = specaccum(comm_matrix, method = "random", permutations = 10)

plot_data = data.frame(
  samples = curve_collector$sites,
  richness = curve_collector$richness
)

ggplot(plot_data, aes(x = samples, y = richness)) +
  geom_line(color = "darkred", linewidth = 1) +
  labs(
    title = "Collectors Curve for Metabolites Sampled",
    x = "Number of Samples",
    y = "Metabolite Richness"
  ) +
  theme_minimal(base_size = 13) +
  theme(
    plot.title = element_text(
      hjust = 0.5,
      face  = "bold",
      color = "black"
    ),
    axis.title = element_text(color = "black"),
    axis.text  = element_text(color = "black")
  )
```

```{r}
#| label: collectors-curve-oculina

oculina_matrix = qc_data |>
  filter(host_genus == "Oculina") |>
  select(c(sample, grep("^x", names(qc_data), value = TRUE))) |>
  column_to_rownames(var = "sample")

oculina_matrix = oculina_matrix |>
  mutate(across(where(is.numeric), ~ ifelse(.x > 0, 1, 0)))

oculina_accum = specaccum(oculina_matrix, method = "random", permutations = 10)

oculina_plot_data = data.frame(
  samples = oculina_accum$sites,
  richness = oculina_accum$richness
)

ggplot(oculina_plot_data, aes(x = samples, y = richness)) +
  geom_line(color = "darkred", linewidth = 1) +
  labs(
    title = "Collectors Curve for Metabolites Sampled (Oculina)",
    x = "Number of Samples",
    y = "Metabolite Richness"
  ) +
  theme_minimal(base_size = 13) +
  theme(
    plot.title = element_text(
      hjust = 0.5,
      face  = "bold",
      color = "black"
    ),
    axis.title = element_text(color = "black"),
    axis.text  = element_text(color = "black")
  )
```

```{r}
#| label: collectors-curve-hawaii

hawaii_matrix = qc_data |>
  filter(location == "Hawaii") |>
  select(c(sample, grep("^x", names(qc_data), value = TRUE))) |>
  column_to_rownames(var = "sample")

hawaii_matrix = hawaii_matrix |>
  mutate(across(where(is.numeric), ~ ifelse(.x > 0, 1, 0)))

hawaii_accum = specaccum(hawaii_matrix, method = "random", permutations = 10)

hawaii_plot_data = data.frame(
  samples = hawaii_accum$sites,
  richness = hawaii_accum$richness
)

ggplot(hawaii_plot_data, aes(x = samples, y = richness)) +
  geom_line(color = "darkred", linewidth = 1) +
  labs(
    title = "Collectors Curve for Metabolites Sampled (Hawaii)",
    x = "Number of Samples",
    y = "Metabolite Richness"
  ) +
  theme_minimal(base_size = 13) +
  theme(
    plot.title = element_text(
      hjust = 0.5,
      face  = "bold",
      color = "black"
    ),
    axis.title = element_text(color = "black"),
    axis.text  = element_text(color = "black")
  )
```

```{r}
#| label: collectors-curve-curacao-scleractinia

curacao_matrix = qc_data |>
  filter(
    location == "CuraÃ§ao",
    host_order == "Scleractinia"
  ) |>
  select(c(sample, grep("^x", names(qc_data), value = TRUE))) |>
  column_to_rownames(var = "sample")

curacao_matrix = curacao_matrix |>
  mutate(across(where(is.numeric), ~ ifelse(.x > 0, 1, 0)))

curacao_accum = specaccum(curacao_matrix, method = "random", permutations = 10)

curacao_plot_data = data.frame(
  samples = curacao_accum$sites,
  richness = curacao_accum$richness
)

ggplot(curacao_plot_data, aes(x = samples, y = richness)) +
  geom_line(color = "darkred", linewidth = 1) +
  labs(
    title = "Collectors Curve for Metabolites Sampled (CuraÃ§ao, Scleractinia)",
    x = "Number of Samples",
   y = "Metabolite Richness") +
  theme_minimal(base_size = 13)
```

```{r}
#| label: collectors-curve-curacao

curacao_comm = qc_data |>
  filter(location == "CuraÃ§ao") |>
  select(c(sample, grep("^x", names(qc_data), value = TRUE))) |>
  column_to_rownames(var = "sample")

curacao_comm = curacao_comm |>
  mutate(across(where(is.numeric), ~ ifelse(.x > 0, 1, 0)))

curacao_curve = specaccum(curacao_comm, method = "random", permutations = 10)

curacao_curve_df = data.frame(
  samples = curacao_curve$sites,
  richness = curacao_curve$richness
)

ggplot(curacao_curve_df, aes(x = samples, y = richness)) +
  geom_line(color = "darkred", linewidth = 1) +
  labs(
    title = "Collectors Curve for Metabolites Sampled (CuraÃ§ao)",
    x = "Number of Samples",
    y = "Metabolite Richness"
  ) +
  theme_minimal(base_size = 13)
```

## PCoA

```{r}
#| label: permanova-location

# 1) select numeric columns (metabolites)
permanova_numeric_data <- qc_data[, sapply(qc_data, is.numeric)]

# 2) find rows with non-missing location AND non-missing numeric values
keep_rows <- !is.na(qc_data$location) &
             apply(permanova_numeric_data, 1, function(x) !any(is.na(x)))

# 3) subset both data objects
permanova_numeric_data2 <- permanova_numeric_data[keep_rows, , drop = FALSE]
meta2 <- qc_data[keep_rows, , drop = FALSE]

# 4) compute Bray-Curtis on the filtered numeric table
bray_curtis2 <- vegdist(permanova_numeric_data2, method = "bray")

# 5) run PERMANOVA with matching metadata
phylum_permanova_result <- adonis2(bray_curtis2 ~ location, data = meta2, permutations = 999)

# 6) show result
print(phylum_permanova_result)
```

```{r}
#| label: PCoA_location

# PCoA (cmdscale) and percent variance explained
pcoa_result <- cmdscale(bray_curtis2, eig = TRUE, k = 2)
pcoa_points <- as.data.frame(pcoa_result$points)
colnames(pcoa_points) <- c("PCoA1", "PCoA2")
pcoa_points <- bind_cols(pcoa_points, meta2)

pos_eig <- pcoa_result$eig[pcoa_result$eig > 0]
var_explained <- round(100 * pcoa_result$eig[1:2] / sum(pos_eig), 1)

#  Plot with 95% confidence ellipses
ggplot(pcoa_points, aes(x = PCoA1, y = PCoA2, color = location, fill = location)) +
  geom_point(size = 3, alpha = 0.8) +
  stat_ellipse(geom = "polygon", alpha = 0.15, level = 0.95, type = "t", colour = NA) +
  labs(
    title = "PCoA of Brayâ€“Curtis Dissimilarity by Location",
    x = paste0("PCoA 1 (", var_explained[1], "%)"),
    y = paste0("PCoA 2 (", var_explained[2], "%)"), 
    fill = "Location", 
    color = "Location"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "right",
    panel.grid = element_blank(),
    plot.title = element_text(face = "bold")
  )
```

```{r}
#| label: permanova-bleaching

# 1) select numeric columns (metabolites)
permanova_numeric_data_bl <- qc_data[, sapply(qc_data, is.numeric)]

# 2) find rows with non-missing location AND non-missing numeric values
keep_rows <- !is.na(qc_data$bleaching) &
             apply(permanova_numeric_data_bl, 1, function(x) !any(is.na(x)))

# 3) subset both data objects
permanova_numeric_data3 <- permanova_numeric_data_bl[keep_rows, , drop = FALSE]
meta2 <- qc_data[keep_rows, , drop = FALSE]

# 4) compute Bray-Curtis on the filtered numeric table
bray_curtis3 <- vegdist(permanova_numeric_data3, method = "bray")

# 5) run PERMANOVA with matching metadata
phylum_permanova_result_1 <- adonis2(bray_curtis3 ~ bleaching, data = meta2, permutations = 999)

# 6) show result
print(phylum_permanova_result_1)
```

```{r}
#| label: PCoA_bleaching

# PCoA (cmdscale) and percent variance explained
pcoa_result <- cmdscale(bray_curtis2, eig = TRUE, k = 2)
pcoa_points <- as.data.frame(pcoa_result$points)
colnames(pcoa_points) <- c("PCoA1", "PCoA2")
pcoa_points <- bind_cols(pcoa_points, meta2)

pos_eig <- pcoa_result$eig[pcoa_result$eig > 0]
var_explained <- round(100 * pcoa_result$eig[1:2] / sum(pos_eig), 1)

# Plot with 95% confidence ellipses
p <- ggplot(pcoa_points, aes(x = PCoA1, y = PCoA2, color = bleaching, fill = bleaching)) +
  geom_point(size = 3, alpha = 0.8) +
  stat_ellipse(geom = "polygon", alpha = 0.15, level = 0.95, type = "t", colour = NA) +
  labs(
    title = "PCoA of Brayâ€“Curtis Dissimilarity by Bleaching Status",
    x = paste0("PCoA1 (", var_explained[1], "%)"),
    y = paste0("PCoA2 (", var_explained[2], "%)"), 
    fill = "Bleaching Status", 
    color = "Bleaching Status"
  ) +
  theme_minimal(base_size = 13) +
  theme(legend.position = "right")

print(p)
```

```{r}
#| label: permanova-hawaii-host-family

# 1) select numeric columns (metabolites)
permanova_numeric_data <- qc_data[, sapply(qc_data, is.numeric)]

# 2) find rows with:
#    - location == "Hawaii"
#    - non-missing host_family
#    - no missing numeric values
keep_rows <- qc_data$location == "Hawaii" &
             !is.na(qc_data$host_family) &
             apply(permanova_numeric_data, 1, function(x) !any(is.na(x)))

# 3) subset both data objects
permanova_numeric_data2 <- permanova_numeric_data[keep_rows, , drop = FALSE]
meta2 <- qc_data[keep_rows, , drop = FALSE]

# 4) compute Bray-Curtis on the filtered numeric table
bray_curtis2 <- vegdist(permanova_numeric_data2, method = "bray")

# 5) run PERMANOVA by host_family (Hawaii samples only)
host_family_permanova_result <- adonis2(
  bray_curtis2 ~ host_family,
  data = meta2,
  permutations = 999
)

# 6) show result
print(host_family_permanova_result)
```

```{r}
#| label: PCoA_hawaii_host_family

# ---- compute PCoA  ----
pcoa_result <- cmdscale(bray_curtis2, eig = TRUE, k = 2)
pcoa_points <- as.data.frame(pcoa_result$points)
colnames(pcoa_points) <- c("PCoA1", "PCoA2")

# attach metadata 
pcoa_points <- bind_cols(pcoa_points, meta2)

# compute percent variance explained (use only positive eigenvalues)
pos_eig <- pcoa_result$eig[pcoa_result$eig > 0]
var_explained <- round(100 * pcoa_result$eig[1:2] / sum(pos_eig), 1)

# add group sizes so we can only draw ellipses for groups with >= 3 samples
library(dplyr)
pcoa_points <- pcoa_points %>%
  group_by(host_family) %>%
  mutate(host_n = n()) %>%
  ungroup()

ellipse_data <- pcoa_points %>% filter(host_n >= 3)

# ---- Plot: color/fill by host_family; ellipses only for groups with >=3 samples ----
library(ggplot2)
p <- ggplot(pcoa_points, aes(x = PCoA1, y = PCoA2, color = host_family, fill = host_family)) +
  geom_point(size = 3, alpha = 0.9) +
  # draw ellipses only for groups with enough points
  stat_ellipse(
    data = ellipse_data,
    aes(x = PCoA1, y = PCoA2, fill = host_family),
    geom = "polygon",
    alpha = 0.15,
    level = 0.95,
    type = "t",
    colour = NA
  ) +
  labs(
    title = "PCoA (Brayâ€“Curtis) â€” Hawaii samples, grouped by host_family",
    x = paste0("PCoA1 (", var_explained[1], "%)"),
    y = paste0("PCoA2 (", var_explained[2], "%)"),
    color = "Host family",
    fill = "Host family"
  ) +
  theme_minimal(base_size = 13) +
  theme(legend.position = "right")

print(p)
```

```{r}
#| label: permanova-sri-lanka-host-family

# 1) select numeric columns (metabolites)
permanova_numeric_data <- qc_data[, sapply(qc_data, is.numeric)]

# 2) find rows with:
#    - location == "Hawaii"
#    - non-missing host_family
#    - no missing numeric values
keep_rows <- qc_data$location == "Sri Lanka" &
             !is.na(qc_data$host_family) &
             apply(permanova_numeric_data, 1, function(x) !any(is.na(x)))

# 3) subset both data objects
permanova_numeric_data2 <- permanova_numeric_data[keep_rows, , drop = FALSE]
meta2 <- qc_data[keep_rows, , drop = FALSE]

# 4) compute Bray-Curtis on the filtered numeric table
bray_curtis2 <- vegdist(permanova_numeric_data2, method = "bray")

# 5) run PERMANOVA by host_family (Hawaii samples only)
host_family_permanova_result <- adonis2(
  bray_curtis2 ~ host_family,
  data = meta2,
  permutations = 999
)

# 6) show result
print(host_family_permanova_result)
```

```{r}
#| label: PCoA_sri_lanka_host_family

# ---- compute PCoA ----
pcoa_result <- cmdscale(bray_curtis2, eig = TRUE, k = 2)
pcoa_points <- as.data.frame(pcoa_result$points)
colnames(pcoa_points) <- c("PCoA1", "PCoA2")

# attach metadata 
pcoa_points <- bind_cols(pcoa_points, meta2)

# compute percent variance explained (use only positive eigenvalues)
pos_eig <- pcoa_result$eig[pcoa_result$eig > 0]
var_explained <- round(100 * pcoa_result$eig[1:2] / sum(pos_eig), 1)

# add group sizes so we can only draw ellipses for groups with >= 3 samples
library(dplyr)
pcoa_points <- pcoa_points %>%
  group_by(host_family) %>%
  mutate(host_n = n()) %>%
  ungroup()

ellipse_data <- pcoa_points %>% filter(host_n >= 3)

# ---- Plot: color/fill by host_family; ellipses only for groups with >=3 samples ----
library(ggplot2)
p <- ggplot(pcoa_points, aes(x = PCoA1, y = PCoA2, color = host_family, fill = host_family)) +
  geom_point(size = 3, alpha = 0.9) +
  # draw ellipses only for groups with enough points
  stat_ellipse(
    data = ellipse_data,
    aes(x = PCoA1, y = PCoA2, fill = host_family),
    geom = "polygon",
    alpha = 0.15,
    level = 0.95,
    type = "t",
    colour = NA
  ) +
  labs(
    title = "PCoA (Brayâ€“Curtis) â€” Sri Lanka samples, grouped by host_family",
    x = paste0("PCoA1 (", var_explained[1], "%)"),
    y = paste0("PCoA2 (", var_explained[2], "%)"),
    color = "Host family",
    fill = "Host family"
  ) +
  theme_minimal(base_size = 13) +
  theme(legend.position = "right")

print(p)
```

```{r}
#| label: permanova-CuraÃ§ao-host-family

# 1) select numeric columns (metabolites)
permanova_numeric_data <- qc_data[, sapply(qc_data, is.numeric)]

# 2) find rows with:
#    - location == "Hawaii"
#    - non-missing host_family
#    - no missing numeric values
keep_rows <- qc_data$location == "CuraÃ§ao" &
             !is.na(qc_data$host_family) &
             apply(permanova_numeric_data, 1, function(x) !any(is.na(x)))

# 3) subset both data objects
permanova_numeric_data2 <- permanova_numeric_data[keep_rows, , drop = FALSE]
meta2 <- qc_data[keep_rows, , drop = FALSE]

# 4) compute Bray-Curtis on the filtered numeric table
bray_curtis2 <- vegdist(permanova_numeric_data2, method = "bray")

# 5) run PERMANOVA by host_family (Hawaii samples only)
host_family_permanova_result <- adonis2(
  bray_curtis2 ~ host_family,
  data = meta2,
  permutations = 999
)

# 6) show result
print(host_family_permanova_result)
```

```{r}
#| label: PCoA_CuraÃ§ao_host_family

# ---- compute PCoA ----
pcoa_result <- cmdscale(bray_curtis2, eig = TRUE, k = 2)
pcoa_points <- as.data.frame(pcoa_result$points)
colnames(pcoa_points) <- c("PCoA1", "PCoA2")

# attach metadata 
pcoa_points <- bind_cols(pcoa_points, meta2)

# compute percent variance explained (use only positive eigenvalues)
pos_eig <- pcoa_result$eig[pcoa_result$eig > 0]
var_explained <- round(100 * pcoa_result$eig[1:2] / sum(pos_eig), 1)

# add group sizes so we can only draw ellipses for groups with >= 3 samples
library(dplyr)
pcoa_points <- pcoa_points %>%
  group_by(host_family) %>%
  mutate(host_n = n()) %>%
  ungroup()

ellipse_data <- pcoa_points %>% filter(host_n >= 3)

# ---- Plot: color/fill by host_family; ellipses only for groups with >=3 samples ----
library(ggplot2)
p <- ggplot(pcoa_points, aes(x = PCoA1, y = PCoA2, color = host_family, fill = host_family)) +
  geom_point(size = 3, alpha = 0.9) +
  # draw ellipses only for groups with enough points
  stat_ellipse(
    data = ellipse_data,
    aes(x = PCoA1, y = PCoA2, fill = host_family),
    geom = "polygon",
    alpha = 0.15,
    level = 0.95,
    type = "t",
    colour = NA
  ) +
  labs(
    title = "PCoA (Brayâ€“Curtis) â€” CuraÃ§ao, grouped by family",
    x = paste0("PCoA1 (", var_explained[1], "%)"),
    y = paste0("PCoA2 (", var_explained[2], "%)"),
    color = "Host family",
    fill = "Host family"
  ) +
  theme_minimal(base_size = 13) +
  theme(legend.position = "right")

print(p)
```

## Ubiquity Abundance Graphs

```{r}
#| label: Metabolite_ubiquity_vs_average_abundance

y_labels_fn <- if (packageVersion("scales") >= "1.2.0") {
  # new API (scales >= 1.2.0)
  label_number(scale_cut = cut_short_scale())
} else {
  # fallback for older scales
  label_number_si()
}

# Select metabolite columns (start with "x")
metabolite_data <- qc_data %>%
  select(starts_with("x"))

# Calculate ubiquity (% samples with metabolite present) and average abundance
metabolite_summary <- metabolite_data %>%
  pivot_longer(
    cols = everything(),
    names_to = "metabolite",
    values_to = "value"
  ) %>%
  group_by(metabolite) %>%
  summarise(
    ubiquity = mean(value > 0) * 100,
    avg_abundance = mean(value, na.rm = TRUE),
    .groups = "drop"
  )

ggplot(metabolite_summary, aes(x = ubiquity, y = avg_abundance)) +
  # use shape=21 (filled circle) so we can have a bold fill + black outline
  geom_point(shape = 21,
             aes(fill = NULL),
             color = "black",       # outline color
             fill = "#E41A1C",      # bold fill (bright red)
             alpha = 0.9,
             size = 2.8,
             stroke = 0.35) +
  scale_y_continuous(labels = y_labels_fn) +
  labs(
    x = "Ubiquity (% samples present)",
    y = "Average abundance",
    title = "Metabolite ubiquity vs average abundance"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    # white overall background and panel
    plot.background   = element_rect(fill = "white", color = NA),
    panel.background  = element_rect(fill = "white", color = NA),
    # grid and axes
    panel.grid.major  = element_line(color = "gray85"),
    panel.grid.minor  = element_blank(),
    axis.line         = element_line(color = "black"),
    # text colors
    plot.title        = element_text(hjust = 0.5, face = "bold", color = "black"),
    axis.title        = element_text(color = "black"),
    axis.text         = element_text(color = "black"),
    legend.position   = "none"
  )
```

```{r}
#| label: Metabolite_ubiquity_vs_average_abundance_scleractinia

y_labels_fn <- if (packageVersion("scales") >= "1.2.0") {
  # new API (scales >= 1.2.0)
  label_number(scale_cut = cut_short_scale())
} else {
  # fallback for older scales
  label_number_si()
}

# --- Compute presence / ubiquity overall and within coral samples ---
met_presence_long <- qc_data %>%
  pivot_longer(
    cols = starts_with("x"),
    names_to = "metabolite",
    values_to = "value"
  ) %>%
  mutate(present = value > 0)

ubiquity_overall <- met_presence_long %>%
  group_by(metabolite) %>%
  summarise(ubiquity_all = mean(present) * 100, .groups = "drop")

ubiquity_corals <- met_presence_long %>%
  filter(host_order == "Scleractinia") %>%
  group_by(metabolite) %>%
  summarise(ubiquity_coral = mean(present) * 100, .groups = "drop")

met_summary <- ubiquity_overall %>%
  left_join(ubiquity_corals, by = "metabolite") %>%
  mutate(ubiquity_coral = ifelse(is.na(ubiquity_coral), 0, ubiquity_coral))

coral_present <- met_presence_long %>%
  filter(host_order == "Scleractinia", present) %>%
  distinct(metabolite)

noncoral_present <- met_presence_long %>%
  filter(host_order != "Scleractinia", present) %>%
  distinct(metabolite)

coral_only <- setdiff(coral_present$metabolite, noncoral_present$metabolite)

met_summary <- met_summary %>%
  left_join(
    met_presence_long %>%
      group_by(metabolite) %>%
      summarise(avg_abundance = mean(value, na.rm = TRUE), .groups = "drop"),
    by = "metabolite"
  ) %>%
  mutate(category = ifelse(metabolite %in% coral_only, "Coral-only", "Other"))

# --- compute x position for vertical line (max overall ubiquity among coral-only mets) ---
x_vline_pos <- met_summary %>%
  filter(category == "Coral-only") %>%
  pull(ubiquity_all) %>%
  { if(length(.) == 0) NA_real_ else max(., na.rm = TRUE) }

# --- Aesthetics: white background, bold fills, black outlines ---
# Choose bold fills: bright red for Coral-only, dark gray for Other
fill_pal <- c("Coral-only" = "#E41A1C", "Other" = "#4D4D4D")
outline_col <- "black"

ggplot(met_summary, aes(x = ubiquity_all, y = avg_abundance, fill = category)) +
  # Other points
  geom_point(
    data = subset(met_summary, category == "Other"),
    aes(x = ubiquity_all, y = avg_abundance),
    shape = 21, size = 3.0, color = outline_col,
    alpha = 0.9, stroke = 0.35, show.legend = TRUE
  ) +
  # Coral-only points
  geom_point(
    data = subset(met_summary, category == "Coral-only"),
    aes(x = ubiquity_all, y = avg_abundance),
    shape = 21, size = 3.2, color = outline_col,
    alpha = 0.95, stroke = 0.45, show.legend = TRUE
  ) +
  # vertical line (if available) in black dashed
  { if (!is.na(x_vline_pos)) geom_vline(xintercept = x_vline_pos, color = "black", linetype = "dashed", linewidth = 0.6) else NULL } +
  scale_fill_manual(
    values = fill_pal,
    breaks = c("Coral-only", "Other"),
    labels = c("Coral-only (Scleractinia)", "Other")
  ) +
  guides(
    fill = guide_legend(
      override.aes = list(
        fill = c(fill_pal["Coral-only"], fill_pal["Other"]),
        color = c(outline_col, outline_col),
        shape = 21,
        size = c(4, 3.5),
        alpha = c(0.95, 0.9),
        stroke = c(0.45, 0.35)
      ),
      direction = "horizontal",
      title = NULL
    )
  ) +
  scale_y_continuous(labels = y_labels_fn) +
  scale_x_continuous(
    limits = c(0, 100),
    breaks = seq(0, 100, by = 20),
    labels = as.character(seq(0, 100, by = 20))
  ) +
  labs(
    x = "Ubiquity (% samples present)",
    y = "Average abundance",
    title = "Metabolite ubiquity vs average abundance"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    # white overall background and panel
    plot.background   = element_rect(fill = "white", color = NA),
    panel.background  = element_rect(fill = "white", color = NA),
    # grid and axes (subtle grid on white)
    panel.grid.major  = element_line(color = "gray90"),
    panel.grid.minor  = element_blank(),
    axis.line         = element_line(color = "black"),
    # text colors
    plot.title        = element_text(hjust = 0.5, face = "bold", color = "black"),
    axis.title        = element_text(color = "black"),
    axis.text         = element_text(color = "black"),
    # legend at bottom, on white background, not overlapping
    legend.position   = "bottom",
    legend.direction  = "horizontal",
    legend.title      = element_blank(),
    legend.text       = element_text(color = "black"),
    legend.background = element_rect(fill = "white", color = NA),
    legend.key        = element_rect(fill = "white", color = NA),
    # tighten spacing so legend doesn't overlap points
    plot.margin = margin(t = 8, r = 8, b = 8, l = 8)
  )
```

Making df turning metabolite columns into rows; includes metabolite abundance.

```{r}
#| label: read-csv-metabolite-clean

metabolite_clean <- read.csv("/Users/ellaandonov/World_Corals/Cleaned data CSVs/metabolite_clean.csv")
```

```{r}
#| label: ubiquity-avg-abundance-all-samples

# Create dataset of ubiquity + average abundance
ubiquity_avg_abundance_values <- qc_data %>%
  # select metabolite columns
  select(starts_with("x")) %>%
  # reshape to long format
  pivot_longer(
    cols = everything(),
    names_to = "metabolite",
    values_to = "value"
  ) %>%
  # compute ubiquity and average abundance
  group_by(metabolite) %>%
  summarise(
    ubiquity = mean(value > 0) * 100,          # % of samples with metabolite present
    avg_abundance = mean(value, na.rm = TRUE), # mean abundance across all samples
    .groups = "drop"
  )

# merge data
merged_metabolite_data <- ubiquity_avg_abundance_values %>%
  left_join(metabolite_clean, by = "metabolite")
```

```{r}
#| label: ubiquity-graph-coral-compound-family

merged_metabolite_data %>%
  group_by(coraldb_compound_family) %>%
  summarise(
    ubiquity = mean(ubiquity, na.rm = TRUE),
    avg_abundance = mean(avg_abundance, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  filter(coraldb_compound_family != "Unknown") %>%
  ggplot(aes(x = ubiquity, y = avg_abundance, color = coraldb_compound_family)) +
  
  geom_point(size = 2.5, alpha = 0.8) +
  
  scale_y_continuous(labels = y_labels_fn) +
  
  labs(
    x = "Ubiquity (% samples present)",
    y = "Average abundance",
    title = "Metabolite ubiquity vs average abundance",
    subtitle = "by coral compound family"
  ) +
  
  theme_minimal(base_size = 14) +
  theme(
    # ---- White background ----
    plot.background  = element_rect(fill = "white", color = NA),
    panel.background = element_rect(fill = "white", color = NA),
    
    # ---- Softer grid ----
    panel.grid.major = element_line(color = "grey85"),
    panel.grid.minor = element_blank(),
    
    # ---- Text styling ----
    plot.title    = element_text(hjust = 0.5, face = "bold", color = "black"),
    plot.subtitle = element_text(
      hjust = 0.5,
      color = "grey30",
      size = 12,
      margin = margin(b = 6)
    ),
    
    axis.title = element_text(color = "black"),
    axis.text  = element_text(color = "black"),
    
    # ---- Legend ----
    legend.position   = "bottom",
    legend.title      = element_blank(),
    legend.text       = element_text(color = "black", size = 8),
    legend.key        = element_rect(fill = "white", color = NA),
    legend.spacing.y  = unit(0.15, "cm"),
    legend.spacing.x  = unit(0.2, "cm"),
    legend.margin     = margin(t = 0, b = 0),
    legend.box.margin = margin(t = -5),
    
    # ---- Margins ----
    plot.margin = margin(t = 10, r = 10, b = 10, l = 10)
  )
```

```{r}
#| label: ubiquity-graph-coral-compound-superclass

merged_metabolite_data %>%
  group_by(coraldb_compound_superclass) %>%
  summarise(
    ubiquity = mean(ubiquity, na.rm = TRUE),
    avg_abundance = mean(avg_abundance, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  filter(coraldb_compound_superclass != "Unknown") %>%
  ggplot(
    aes(
      x = ubiquity,
      y = avg_abundance,
      color = coraldb_compound_superclass
    )
  ) +
  
  geom_point(size = 2.2, alpha = 0.8) +
  
  scale_y_continuous(labels = y_labels_fn) +
  
  labs(
    x = "Ubiquity (% samples present)",
    y = "Average abundance",
    title = "Metabolite ubiquity vs average abundance",
    subtitle = "by coral compound superclass"
  ) +
  
  theme_minimal(base_size = 12) +
  theme(
    # ---- White background ----
    plot.background  = element_rect(fill = "white", color = NA),
    panel.background = element_rect(fill = "white", color = NA),
    
    # ---- Grid ----
    panel.grid.major = element_line(color = "grey85"),
    panel.grid.minor = element_blank(),
    
    # ---- Text ----
    plot.title    = element_text(hjust = 0.5, face = "bold", color = "black", size = 13),
    plot.subtitle = element_text(hjust = 0.5, color = "grey30", size = 10),
    axis.title    = element_text(color = "black", size = 11),
    axis.text     = element_text(color = "black", size = 10),
    
    # ---- Legend (stacked vertically) ----
    legend.position    = "bottom",
    legend.title       = element_blank(),
    legend.text        = element_text(size = 6),
    legend.key.height  = unit(0.2, "cm"),
    legend.key.width   = unit(0.4, "cm"),
    legend.spacing.y   = unit(0.03, "cm"),
    legend.spacing.x   = unit(0.1, "cm"),
    
    # extra room for stacked legend
    plot.margin = margin(t = 6, r = 8, b = 20, l = 8)
  ) +
  
  guides(
    color = guide_legend(
      nrow = 5,      # ðŸ‘ˆ stack more than three entries
      byrow = TRUE
    )
  )
```

## Box and Whiskers Plots

```{r}
#| label: avg-met-abundance-box-and-whisker

library(dplyr)
library(ggplot2)

# 1) identify metabolite (numeric) columns
metabolite_data <- qc_data %>%
  select(where(is.numeric))

# 2) calculate average metabolite abundance per sample
avg_abundance <- metabolite_data %>%
  mutate(avg_abundance = rowMeans(., na.rm = TRUE)) %>%
  select(avg_abundance)

# 3) build plotting dataframe
plot_data <- qc_data %>%
  select(host_order) %>%
  bind_cols(avg_abundance) %>%
  mutate(
    group = ifelse(host_order == "Scleractinia",
                   "Scleractinia",
                   "All samples")
  )

ggplot(plot_data, aes(x = group, y = avg_abundance, fill = group)) +
  geom_boxplot(alpha = 0.7, width = 0.6, outlier.shape = 16) +
  labs(
    title = "Average Metabolite Abundance per Sample",
    x = "",
    y = "Average Metabolite Abundance"
  ) +
  theme_minimal(base_size = 13) +
  theme(
    legend.position = "none",
    plot.title = element_text(
      hjust = 0.5,      # center title
      face = "bold",    # bold title
      color = "black"
    ),
    axis.title = element_text(color = "black"),
    axis.text  = element_text(color = "black")
  )
```

```{r}
#| label: avg-met-ubiquity-box-and-whisker

library(dplyr)
library(ggplot2)

# 1) identify metabolite (numeric) columns
metabolite_data <- qc_data %>%
  select(where(is.numeric))

# 2) calculate average ubiquity per sample
#    (fraction of metabolites present)
avg_ubiquity <- metabolite_data %>%
  mutate(avg_ubiquity = rowMeans(. > 0, na.rm = TRUE)) %>%
  select(avg_ubiquity)

# 3) build plotting dataframe
plot_data <- qc_data %>%
  select(host_order) %>%
  bind_cols(avg_ubiquity) %>%
  mutate(
    group = ifelse(host_order == "Scleractinia",
                   "Scleractinia",
                   "All samples")
  )

ggplot(plot_data, aes(x = group, y = avg_ubiquity, fill = group)) +
  geom_boxplot(alpha = 0.7, width = 0.6, outlier.shape = 16) +
  labs(
    title = "Average Metabolite Ubiquity per Sample",
    x = "",
    y = "Proportion of Metabolites Detected"
  ) +
  theme_minimal(base_size = 13) +
  theme(
    legend.position = "none",
    plot.title = element_text(
      hjust = 0.5,      # center title
      face = "bold",    # bold title
      color = "black"
    ),
    axis.title = element_text(color = "black"),
    axis.text  = element_text(color = "black")
  )
```

## NPC Classifiers

```{r}
#| label: read_csv

metabolite_df <- read.csv("/Users/ellaandonov/World_Corals/Cleaned data CSVs/metabolite_clean.csv")
```

```{r}
#| label: ubiquity-avg-abundance-all-samples

# Create dataset of ubiquity + average abundance
ubiquity_avg_abundance_values <- qc_data %>%
  # select metabolite columns
  select(starts_with("x")) %>%
  # reshape to long format
  pivot_longer(
    cols = everything(),
    names_to = "metabolite",
    values_to = "value"
  ) %>%
  # compute ubiquity and average abundance
  group_by(metabolite) %>%
  summarise(
    ubiquity = mean(value > 0) * 100,          # % of samples with metabolite present
    avg_abundance = mean(value, na.rm = TRUE), # mean abundance across all samples
    .groups = "drop"
  )
```

```{r}
#| label: merge-data

merged_metabolite_data <- ubiquity_avg_abundance_values %>%
  left_join(metabolite_df, by = "metabolite")
```

```{r}
#| label: unique-outputs-per-column 
library(dplyr)

merged_metabolite_data %>%
  summarise(across(everything(), ~ n_distinct(.)))
```
