---
title: "qc_data_graphs"
format: html
---

## Library and Data

```{r}
#| label: library_function 

library(tidyverse)
library(knitr)
library(readxl)
library(data.table)
library(vegan)
library(scales)
```

```{r}
#| label: read-csvs

qc_data <- read.csv("/Users/ellaandonov/World_Corals/Metabolite Summary Data/qc_data.csv")
```

## Taxonomic Counts

```{r}
#| label: taxonomic-counts

# Count unique categories for each taxonomic level
taxonomic_counts <- qc_data %>%
  summarise(across(
    c(host_phylum, host_class, host_order, host_genus, host_species), 
    ~n_distinct(.x, na.rm = TRUE)
  )) %>%
  # Optional: Pivot to long format for a cleaner table view
  tidyr::pivot_longer(
    cols = everything(), 
    names_to = "Taxonomic_Level", 
    values_to = "Unique_Count"
  )

# View the counts
print(taxonomic_counts)
```

## Dendrograms 

```{r}
avg_metabolite_values_family <- qc_data |>
  group_by(host_family) |> 
  filter(!is.na(host_family)) |> 
  summarise(across(starts_with("x"), mean, na.rm = TRUE)) |>
  ungroup()
```

```{r}
# turn host_family into rownames and create numeric matrix for vegdist
mat_family <- avg_metabolite_values_family %>%
  as.data.frame()                     # ensure data.frame for rownames()
rownames(mat_family) <- mat_family$host_family
mat_family <- mat_family[ , setdiff(names(mat_family), "host_family")]  # drop the column now that it's rownames

mat_family[] <- lapply(mat_family, as.numeric)

mat_family <- mat_family %>%
  mutate_all(~ifelse(is.na(.), 0, .))   # replace NAs with 0s (common for abundance data)
```

```{r}
bray_curtis_family <- vegdist (sqrt (mat_family), method = 'bray') 
# percentage cover data are transformed by square root
cluster.single <- hclust (d = bray_curtis_family, method = 'single')
cluster.complete <- hclust (bray_curtis_family, 'complete')
cluster.average <- hclust (bray_curtis_family, 'average')
```

```{r}
# Set background color for the plot area and device
par(bg = "#000042")               # device background
par(col = "white",                # axis & text color
    col.axis = "white",
    col.lab  = "white",
    col.main = "white",
    col.sub  = "white",
    fg = "white")                 # foreground (box, axes)

# Plot dendrogram with white lines and labels
plot(cluster.average,
     main = "Dendrogram by Family",
     xlab = "Families",
     sub = "",
     cex = 0.6,
     col = "white",               # dendrogram lines
     col.lab = "white",
     col.main = "white",
     col.axis = "white",
     labels = cluster.average$labels,
     col.lab = "white")

# Draw cluster rectangles in white
rect.hclust(cluster.average, k = 10, border = "white", lwd = 2)

```

```{r}
#| label: dendrogram-host-origin 

# Get the metabolites that are not Host
not_host_metabolite = metabolite_clean |>
  filter(!(refined_origin %in% c("Host", "Unknown"))) |>
  pull(metabolite)

avg_metabolite_values_family_host = avg_metabolite_values_family |>
  select(-any_of(not_host_metabolite))

# turn host_family into rownames and create numeric matrix for vegdist
mat_family <- avg_metabolite_values_family_host %>%
  as.data.frame()                     # ensure data.frame for rownames()
rownames(mat_family) <- mat_family$host_family
mat_family <- mat_family[ , setdiff(names(mat_family), "host_family")]  # drop the column now that it's rownames

mat_family[] <- lapply(mat_family, as.numeric)

mat_family <- mat_family %>%
  mutate_all(~ifelse(is.na(.), 0, .))   # replace NAs with 0s (common for abundance data)
```

```{r}
bray_curtis_family <- vegdist (sqrt (mat_family), method = 'bray') 
# percentage cover data are transformed by square root
cluster.single <- hclust (d = bray_curtis_family, method = 'single')
cluster.complete <- hclust (bray_curtis_family, 'complete')
cluster.average <- hclust (bray_curtis_family, 'average')
```

```{r}
# Set background color for the plot area and device
par(bg = "#000042")               # device background
par(col = "white",                # axis & text color
    col.axis = "white",
    col.lab  = "white",
    col.main = "white",
    col.sub  = "white",
    fg = "white")                 # foreground (box, axes)

# Plot dendrogram with white lines and labels
plot(cluster.average,
     main = "Dendrogram by Family, Host Origin Only",
     xlab = "Families",
     sub = "",
     cex = 0.6,
     col = "white",               # dendrogram lines
     col.lab = "white",
     col.main = "white",
     col.axis = "white",
     labels = cluster.average$labels,
     col.lab = "white")

# Draw cluster rectangles in white
rect.hclust(cluster.average, k = 10, border = "white", lwd = 2)

```

## Collectors Curve 

```{r}
#| label: collectors-curve

comm_matrix = qc_data |>
  select(c(sample, grep("^x", names(qc_data), value = TRUE))) |>
  column_to_rownames(var = "sample")

comm_matrix = comm_matrix |>
  mutate(across(where(is.numeric), ~ ifelse(.x > 0, 1, 0)))

curve_collector = specaccum(comm_matrix, method = "random", permutations = 10)

```

```{r}
plot_data = data.frame(
  samples = curve_collector$sites,
  richness = curve_collector$richness
)

ggplot(plot_data, aes(x = samples, y = richness)) +
  geom_line(color = "darkred")
```

## PCoA

```{r}
#| label: permanova-location

# 1) select numeric columns (metabolites)
permanova_numeric_data <- qc_data[, sapply(qc_data, is.numeric)]

# 2) find rows with non-missing location AND non-missing numeric values
keep_rows <- !is.na(qc_data$location) &
             apply(permanova_numeric_data, 1, function(x) !any(is.na(x)))

# 3) subset both data objects
permanova_numeric_data2 <- permanova_numeric_data[keep_rows, , drop = FALSE]
meta2 <- qc_data[keep_rows, , drop = FALSE]

# 4) compute Bray-Curtis on the filtered numeric table
bray_curtis2 <- vegdist(permanova_numeric_data2, method = "bray")

# 5) run PERMANOVA with matching metadata
phylum_permanova_result <- adonis2(bray_curtis2 ~ location, data = meta2, permutations = 999)

# 6) show result
print(phylum_permanova_result)
```

```{r}
#| label: PCoA_location

# PCoA (cmdscale) and percent variance explained
pcoa_result <- cmdscale(bray_curtis2, eig = TRUE, k = 2)
pcoa_points <- as.data.frame(pcoa_result$points)
colnames(pcoa_points) <- c("PCoA1", "PCoA2")
pcoa_points <- bind_cols(pcoa_points, meta2)

pos_eig <- pcoa_result$eig[pcoa_result$eig > 0]
var_explained <- round(100 * pcoa_result$eig[1:2] / sum(pos_eig), 1)

#  Plot with 95% confidence ellipses
ggplot(pcoa_points, aes(x = PCoA1, y = PCoA2, color = location, fill = location)) +
  geom_point(size = 3, alpha = 0.8) +
  stat_ellipse(geom = "polygon", alpha = 0.15, level = 0.95, type = "t", colour = NA) +
  labs(
    title = "PCoA of Bray–Curtis Dissimilarity by Location",
    x = paste0("PCoA 1 (", var_explained[1], "%)"),
    y = paste0("PCoA 2 (", var_explained[2], "%)"), 
    fill = "Location", 
    color = "Location"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "right",
    panel.grid = element_blank(),
    plot.title = element_text(face = "bold")
  )
```

```{r}
#| label: PCoA_bleaching

# PCoA (cmdscale) and percent variance explained
pcoa_result <- cmdscale(bray_curtis2, eig = TRUE, k = 2)
pcoa_points <- as.data.frame(pcoa_result$points)
colnames(pcoa_points) <- c("PCoA1", "PCoA2")
pcoa_points <- bind_cols(pcoa_points, meta2)

pos_eig <- pcoa_result$eig[pcoa_result$eig > 0]
var_explained <- round(100 * pcoa_result$eig[1:2] / sum(pos_eig), 1)

# Plot with 95% confidence ellipses
p <- ggplot(pcoa_points, aes(x = PCoA1, y = PCoA2, color = bleaching, fill = bleaching)) +
  geom_point(size = 3, alpha = 0.8) +
  stat_ellipse(geom = "polygon", alpha = 0.15, level = 0.95, type = "t", colour = NA) +
  labs(
    title = "PCoA of Bray–Curtis Dissimilarity by Bleaching Status",
    x = paste0("PCoA1 (", var_explained[1], "%)"),
    y = paste0("PCoA2 (", var_explained[2], "%)"), 
    fill = "Bleaching Status", 
    color = "Bleaching Status"
  ) +
  theme_minimal(base_size = 13) +
  theme(legend.position = "right")

print(p)
```

```{r}
#| label: permanova-hawaii-host-family

# 1) select numeric columns (metabolites)
permanova_numeric_data <- qc_data[, sapply(qc_data, is.numeric)]

# 2) find rows with:
#    - location == "Hawaii"
#    - non-missing host_family
#    - no missing numeric values
keep_rows <- qc_data$location == "Hawaii" &
             !is.na(qc_data$host_family) &
             apply(permanova_numeric_data, 1, function(x) !any(is.na(x)))

# 3) subset both data objects
permanova_numeric_data2 <- permanova_numeric_data[keep_rows, , drop = FALSE]
meta2 <- qc_data[keep_rows, , drop = FALSE]

# 4) compute Bray-Curtis on the filtered numeric table
bray_curtis2 <- vegdist(permanova_numeric_data2, method = "bray")

# 5) run PERMANOVA by host_family (Hawaii samples only)
host_family_permanova_result <- adonis2(
  bray_curtis2 ~ host_family,
  data = meta2,
  permutations = 999
)

# 6) show result
print(host_family_permanova_result)
```

```{r}
#| label: PCoA_hawaii_host_family

# ---- compute PCoA  ----
pcoa_result <- cmdscale(bray_curtis2, eig = TRUE, k = 2)
pcoa_points <- as.data.frame(pcoa_result$points)
colnames(pcoa_points) <- c("PCoA1", "PCoA2")

# attach metadata 
pcoa_points <- bind_cols(pcoa_points, meta2)

# compute percent variance explained (use only positive eigenvalues)
pos_eig <- pcoa_result$eig[pcoa_result$eig > 0]
var_explained <- round(100 * pcoa_result$eig[1:2] / sum(pos_eig), 1)

# add group sizes so we can only draw ellipses for groups with >= 3 samples
library(dplyr)
pcoa_points <- pcoa_points %>%
  group_by(host_family) %>%
  mutate(host_n = n()) %>%
  ungroup()

ellipse_data <- pcoa_points %>% filter(host_n >= 3)

# ---- Plot: color/fill by host_family; ellipses only for groups with >=3 samples ----
library(ggplot2)
p <- ggplot(pcoa_points, aes(x = PCoA1, y = PCoA2, color = host_family, fill = host_family)) +
  geom_point(size = 3, alpha = 0.9) +
  # draw ellipses only for groups with enough points
  stat_ellipse(
    data = ellipse_data,
    aes(x = PCoA1, y = PCoA2, fill = host_family),
    geom = "polygon",
    alpha = 0.15,
    level = 0.95,
    type = "t",
    colour = NA
  ) +
  labs(
    title = "PCoA (Bray–Curtis) — Hawaii samples, grouped by host_family",
    x = paste0("PCoA1 (", var_explained[1], "%)"),
    y = paste0("PCoA2 (", var_explained[2], "%)"),
    color = "Host family",
    fill = "Host family"
  ) +
  theme_minimal(base_size = 13) +
  theme(legend.position = "right")

print(p)
```

```{r}
#| label: permanova-sri-lanka-host-family

# 1) select numeric columns (metabolites)
permanova_numeric_data <- qc_data[, sapply(qc_data, is.numeric)]

# 2) find rows with:
#    - location == "Hawaii"
#    - non-missing host_family
#    - no missing numeric values
keep_rows <- qc_data$location == "Sri Lanka" &
             !is.na(qc_data$host_family) &
             apply(permanova_numeric_data, 1, function(x) !any(is.na(x)))

# 3) subset both data objects
permanova_numeric_data2 <- permanova_numeric_data[keep_rows, , drop = FALSE]
meta2 <- qc_data[keep_rows, , drop = FALSE]

# 4) compute Bray-Curtis on the filtered numeric table
bray_curtis2 <- vegdist(permanova_numeric_data2, method = "bray")

# 5) run PERMANOVA by host_family (Hawaii samples only)
host_family_permanova_result <- adonis2(
  bray_curtis2 ~ host_family,
  data = meta2,
  permutations = 999
)

# 6) show result
print(host_family_permanova_result)
```

```{r}
#| label: PCoA_sri_lanka_host_family

# ---- compute PCoA ----
pcoa_result <- cmdscale(bray_curtis2, eig = TRUE, k = 2)
pcoa_points <- as.data.frame(pcoa_result$points)
colnames(pcoa_points) <- c("PCoA1", "PCoA2")

# attach metadata 
pcoa_points <- bind_cols(pcoa_points, meta2)

# compute percent variance explained (use only positive eigenvalues)
pos_eig <- pcoa_result$eig[pcoa_result$eig > 0]
var_explained <- round(100 * pcoa_result$eig[1:2] / sum(pos_eig), 1)

# add group sizes so we can only draw ellipses for groups with >= 3 samples
library(dplyr)
pcoa_points <- pcoa_points %>%
  group_by(host_family) %>%
  mutate(host_n = n()) %>%
  ungroup()

ellipse_data <- pcoa_points %>% filter(host_n >= 3)

# ---- Plot: color/fill by host_family; ellipses only for groups with >=3 samples ----
library(ggplot2)
p <- ggplot(pcoa_points, aes(x = PCoA1, y = PCoA2, color = host_family, fill = host_family)) +
  geom_point(size = 3, alpha = 0.9) +
  # draw ellipses only for groups with enough points
  stat_ellipse(
    data = ellipse_data,
    aes(x = PCoA1, y = PCoA2, fill = host_family),
    geom = "polygon",
    alpha = 0.15,
    level = 0.95,
    type = "t",
    colour = NA
  ) +
  labs(
    title = "PCoA (Bray–Curtis) — Sri Lanka samples, grouped by host_family",
    x = paste0("PCoA1 (", var_explained[1], "%)"),
    y = paste0("PCoA2 (", var_explained[2], "%)"),
    color = "Host family",
    fill = "Host family"
  ) +
  theme_minimal(base_size = 13) +
  theme(legend.position = "right")

print(p)
```

```{r}
#| label: permanova-Curaçao-host-family

# 1) select numeric columns (metabolites)
permanova_numeric_data <- qc_data[, sapply(qc_data, is.numeric)]

# 2) find rows with:
#    - location == "Hawaii"
#    - non-missing host_family
#    - no missing numeric values
keep_rows <- qc_data$location == "Curaçao" &
             !is.na(qc_data$host_family) &
             apply(permanova_numeric_data, 1, function(x) !any(is.na(x)))

# 3) subset both data objects
permanova_numeric_data2 <- permanova_numeric_data[keep_rows, , drop = FALSE]
meta2 <- qc_data[keep_rows, , drop = FALSE]

# 4) compute Bray-Curtis on the filtered numeric table
bray_curtis2 <- vegdist(permanova_numeric_data2, method = "bray")

# 5) run PERMANOVA by host_family (Hawaii samples only)
host_family_permanova_result <- adonis2(
  bray_curtis2 ~ host_family,
  data = meta2,
  permutations = 999
)

# 6) show result
print(host_family_permanova_result)
```

```{r}
#| label: PCoA_Curaçao_host_family

# ---- compute PCoA ----
pcoa_result <- cmdscale(bray_curtis2, eig = TRUE, k = 2)
pcoa_points <- as.data.frame(pcoa_result$points)
colnames(pcoa_points) <- c("PCoA1", "PCoA2")

# attach metadata 
pcoa_points <- bind_cols(pcoa_points, meta2)

# compute percent variance explained (use only positive eigenvalues)
pos_eig <- pcoa_result$eig[pcoa_result$eig > 0]
var_explained <- round(100 * pcoa_result$eig[1:2] / sum(pos_eig), 1)

# add group sizes so we can only draw ellipses for groups with >= 3 samples
library(dplyr)
pcoa_points <- pcoa_points %>%
  group_by(host_family) %>%
  mutate(host_n = n()) %>%
  ungroup()

ellipse_data <- pcoa_points %>% filter(host_n >= 3)

# ---- Plot: color/fill by host_family; ellipses only for groups with >=3 samples ----
library(ggplot2)
p <- ggplot(pcoa_points, aes(x = PCoA1, y = PCoA2, color = host_family, fill = host_family)) +
  geom_point(size = 3, alpha = 0.9) +
  # draw ellipses only for groups with enough points
  stat_ellipse(
    data = ellipse_data,
    aes(x = PCoA1, y = PCoA2, fill = host_family),
    geom = "polygon",
    alpha = 0.15,
    level = 0.95,
    type = "t",
    colour = NA
  ) +
  labs(
    title = "PCoA (Bray–Curtis) — Curaçao samples, grouped by host_family",
    x = paste0("PCoA1 (", var_explained[1], "%)"),
    y = paste0("PCoA2 (", var_explained[2], "%)"),
    color = "Host family",
    fill = "Host family"
  ) +
  theme_minimal(base_size = 13) +
  theme(legend.position = "right")

print(p)
```
